<!DOCTYPE html>
<html lang="en">
<head>
    <title>ROCA Activator Template</title>
</head>
<body>
<div>
    <h2>What is ROCA?</h2>
    <p>ROCA is a collection of recommendations for decent Web application frontends. You can read more about it on <a
        href="http://roca-style.org/">roca-style.org</a>.</p>
    <p>This application serves as an example of how the ROCA recommendations can be applied using the <a
        href="http://www.playframework.com/">Play Framework</a>. Each section of this tutorial refers to one of the
    ROCA principles and describes how it is applied in the example application.</p>
</div>
<div>
    <h2>REST</h2>
    <p>
        ROCA applications <a href="http://roca-style.org/#rest">adhere to the principles of REST</a>,
        which means that they expose one or more resources whose state is solely maintained by
        the server, allowing for stateless communication.
    </p>
    <p>
        Each resource has its own URI, which means that it can be bookmarked and linked to from
        other resources.
    </p>
    <p>
        When providing representations of resources, the server should leverage the ability to link
        to other resources to inform the user about meaningful next possible steps.
    </p>
    <p>
        For instance, in our example application we have a collection resource of all the issues
        created by users. This collection is
        <a href="#code/app/views/pagination.scala.html" class="shortcut">paginated</a>, and the
        HTML representation of an issues page contains a link to the previous page, if there is
        one, and to the next page, again if another page exists.
    </p>
    <p>The semantics of these links are also machine-readable, because they
        are annotated with the IANA-standardised and hence well-understood
        <code>previous</code> and <code>next</code> link relations, respectively.</p>
</div>
<div>
    <h2>Should formats</h2>
    <p>
        In ROCA applications, the primary format for providing representations of resources is HTML.
        However, representations in other formats like JSON or XML may be provided, primarily for
        consumption by other applications, not for consumption by JavaScript running in the browser.
    </p>
</div>
<div>
    <h2>Unobtrusive JavaScript</h2>
    <p>ROCA applications <a href="http://roca-style.org/#unobtrusive-javascript">use JavaScript unobtrusively</a> and
    remain usable when JavaScript is disabled or just doesn't happen to work. You can see this principle applied on
    the list of issues in the example application.</p>
    <p>When browsing through the list of issues without using JavaScript,
    the entire DOM is refreshed when viewing the next page or filtering for a specific project. If, on the other hand,
    JavaScript is available, only the part of the DOM that has actually changed (the list of issues) is updated.</p>
    <p>Hence, JavaScript is used solely to enhance the user experience, but the functionality (filtering, pagination etc.)
        remains usable if JavaScript doesn't work.</p>
    <p>There is not a lot you need to do in your server-side Play code in order to support this principle.
    All you need to do is serve both full HTML representations of your resources (i.e. the HTML
        includes the surrounding layout) and partial HTML without the surrounding layout.</p>
    <p>The former needs to be served in case of a full page load. If JavaScript is working,
    however, the client can make use of PJAX, updating the DOM with the partial HTML and <a href="http://roca-style.org/#historyapi">using
    the HTML5 History API</a> to update the browser's current URL.</p>
    <p>We make use of a <a href="#code/app/helpers/ConditionalLayout.scala" class="shortcut">custom Play action builder</a>
        in order to provide an enriched request to our controller that holds information on whether
    a full layout is required or not. This is determined based on the presence and value of the
    <code>X-PJAX</code> HTTP request header.</p>
    <p>The <a href="#code/app/controllers/Issues.scala" class="shortcut">Issues controller</a>
    makes use of this to render a different view, depending on whether a layout is required
    or not.</p>
</div>
<div>
    <h2>Application logic</h2>
    <p>
        Another core principle of ROCA applications is that
        <a href="http://roca-style.org/#application-logic">all application logic resides on
        the server</a>.
    </p>
    <p>
        This not only due to the fact that the application should be usable
        without JavaScript, but also, and more importantly, because ultimately, only the server
        has the authority to validate the users' input and interactions â€“ they cannot and must not
        rely on the client having done some or all of the necessary checks and validations.
    </p>
    <p>
        In order to improve the user experience and usability, it is often necessary to to perform
        some validations already in the browser, if JavaScript is working. However, these must never replace validations
        performed by the server, and the
        <a href="http://roca-style.org/#no-duplication">corresponding logic must not be duplicated</a>.
    </p>
    <p>
        Instead, the server can provide information about the respective constraints
        in a declarative way that can be processed in the browser without knowledge of the
        specific application logic.
    </p>
    <p>
        This can be done by means of custom data attributes in the HTML markup that can then be processed
        by a generic JavaScript validation library. Alternatively, the information could be supplied using the HTML5
        attributes for specifying validation constraints on form elements and then evaluated by means of the HTML5
        constraint validation JavaScript API.
    </p>
    <p>
        You can see this principle applied in the
        <a href="#code/app/views/issueForm.scala.html" class="shortcut">issue form</a> for submitting a new
        issue. Here, instead of calling the default template for creating an input text element,
        we make use of our own custom helper template, the
        <a href="#code/app/views/issueForm.scala.html" class="shortcut">validatingInputText</a>.
    </p>
    <p>
        This serves as an oversimplified demonstration of how to attach additional constraint
        attributes to an input element in Play, based on the constraints specified in the mapping for the
        respective field using Play's Form API. In this case, the form mapping that serves as the
        source for the constraint attributes on the input elements is the <code>issueForm</code>
        defined in the
        <a href="#code/app/controllers/Issues.scala" class="shortcut">Issues controller</a>.
    </p>
</div>
</body>
</html>
